#!/usr/bin/env python
# vi: ts=4:sw=4:sts=4:et

import re

class Command(object):
    def __init__(self):
        self.name = None
        self.description = None
        self.options = {}

    def add_description(self, desc, loc):
        if self.description is None:
            self.description = desc
        else:
            self.description += ' ' + desc

    def add_option(self, optstr, loc):
        m = re.match('([a-z0-9_]+) *= *(.*)', optstr)
        if not m:
            raise ValueError('%s: Bad option syntax: %r' % (loc, optstr))
        key, val = m.groups()
        if key not in KNOWN_OPTIONS:
            raise ValueError('%s: Unknown option: %r' % (loc, key))
        if key in self.options:
            raise ValueError('%s: Duplicate option: %r' % (loc, key))
        self.options[key] = val

def collect_commands(filename, commands):
    cur = None
    for lineno, line in enumerate(open(filename)):
        line = line.strip()
        if re.match('// \[Command\]', line):
            cur = Command()
            commands.append(cur)
        elif cur is not None:
            m = re.match(r'status ([a-z0-9_]+)\(int argc, char.. argv\) {', line)
            if m:
                cur.name = m.group(1)
                cur = None
            else:
                loc = '%s:%d' % (filename, lineno+1)
                m = re.match('// ([A-Za-z]*): *(.*)', line)
                if not m:
                    raise ValueError('%s: Bad line %r' % (loc, line))
                if m.group(1) == 'Description':
                    cur.add_description(m.group(2).strip(), loc)
                elif m.group(1) == 'Option':
                    cur.add_option(m.group(2).strip(), loc)
                else:
                    raise ValueError("%s: Bad keyword %r" % (loc, m.group(1)))

KNOWN_OPTIONS = {'open_usb', 'default_usb_device'}

def output_table(commands):
    commands.sort(key=lambda c:c.name)
    print '// Generated by command_table.py; do not edit.'
    print ''
    print '#include "command.h"'
    print ''
    for c in commands:
        print 'status %s(int argc, char** argv);' % c.name
    print ''
    print 'static struct command all_commands_table[] = {'
    for c in commands:
        print '{'
        print '  .name = "%s",' % c.name
        print '  .fn = %s,' % c.name
        print '  .desc = "%s",' % c.description
        print '  .open_usb = %s,' % c.options.get('open_usb', 'false')
        print '  .default_usb_device = %s,' % (
                '"%s"' % c.options['default_usb_device']
                if 'default_usb_device' in c.options else '(const char*)0')
        print '},'
    print '{.name = 0},'
    print '};'
    print 'struct command* all_commands = all_commands_table;'

def main(argv):
    commands = []
    for filename in argv:
        collect_commands(filename, commands)
    output_table(commands)

if __name__ == '__main__':
    import sys
    main(sys.argv[1:])
