# 2020-04-11

A somewhat belated update: PCB layout is basically done except for the analog block (below), and the FPGA's decoupling capacitors. Those will probably have to be `0402`-sized parts, though, which based on practice, is about twice as annoying as `0603` parts. However, they won't fit conveniently under the FPGA otherwise -- it's not too bad.

Generally speaking, PCB layout is tricky.  

I've verified that JLCPCB can (at least in theory) produce boards with 0.2mm vias and 0.01mm traces -- that's right at the edge of their design rules, though. Unfortunately they charge a lot more for boards to that spec (it's cheaper with 0.45mm-minimum vias). Vaugely estimated cost is $90 per five boards; mostly in engineering setup cost. I don't expect to make more than a dozen of these at most, but board re-spins will be costly, so I want to try and get as much right the first time as possible.

I've documented my [design deficiencies](../design/deficiencies.md) and I'll add my part selection rationale soon. No clue if any of these things matter, but it's good to note them so I can kick myself appropriately later.

## Analog Again

Turns out, analog electronics is complicated. Who knew? From my partial, amateur understanding:

A high-impedence analog output isn't able to source very much current (high resistance, hence low current). However, most ADC chips need a small-but-nontrivial amount of current to work properly. In that case, we need an amplifier of some sort to provide the higher current, while tracking the voltages. I suspect this is the case for the PPU2 analog outputs, since they're amplified by two transistors in the SNES schematic for the component output. However, I'm not really sure of the voltage range, which appears to be 0 - 2.7V or so -- need to re-check this on the SNES. (Curiously my actual SNES board only has one transistor instead of two -- I suspect that either this revision of the board simplified it, or else it's a Darlington pair package).

So, to take one step up the over-enginerring ladder: I can solve this problem with an opamp -- except that they usually can't drive all the way to the maximum or minimum voltage, and so require wacky negative voltages, and cheap ones have a very slow slew rate (so they can't keep up with the ~3-5MHz signals). I could generate the negative voltage from the input using another regulator (there's a buck convertor topology that produces negative voltage), but it's complicated, and I went through about a dozen random (wrong) ideas to avoid this. However, I then found an opamp that only requires a single supply, and is "rail-to-rail", so it should be able to produce the full range, and has a whopping 345MHz bandwidth: the `LMH6611`.

Also conveniently, the `LMH6611` datasheet has an example application of it as a "Single-to-single ADC driver" (page 24-25), which is pretty close to what I need. This example sets up an inverting amplifer in a second order multiple-feedback topology, and has a cutoff frequency of 500kHz (which is too low, since I have 3.58MHz signal), and it's set up with negative gain across a 2.5V reference voltage (compared to a 5V VCC). I verified this with [some random amplifier tool I found online](http://sim.okawa-denshi.jp/en/Fkeisan.htm), and it seems to check out. This is pretty reasonable, but I also need to drop the voltage range into the 2V peak-to-peak limitation of the ADC. This, I can do with a fairly simple resistor network, which can simultaneously drop the range from 2.7V down to 1.8V, and push up the minimum voltage from 0V to 0.1V. This should give me a 1.8V range, with enough space for off-scale-high and off-scale-low. However, I'll need to use a non-inverting topology, but the datasheet claims "the inverting configuration ... offers a more linear output resposne," which I plan to ignore.  As a side-note, KiCad / eeschema has a simulation mode with ngspice built-in. It's a bit touchy, but very handy for simple simulation.

The really handy thing about all this, is that I can change the resistor values to tweak voltage levels, without re-spinning the board or doing complicated rework. Fortunately this doesn't have to be very accurate, because I only need to recover a 5-bit-depth signal, and 8-bit ought to be more than enough for that. I can use the digital outputs of the `PPU2.TST{0..14}` pins to self-calibrate, and have the FPGA do the mapping directly. Neat. There might be some skew over a frame, though, which I'll have to be careful of.

I've also switched from the `ADS9280` to the `ADC1173`, because I don't need the more advanced features, and the chip is half the cost (~$9 savings per board). As a bonus, the datasheet has a couple of application examples, which are nice but not quite exactly what I need. I'm concerned that the datasheet specifically says to use a dedicated power supply, and not the same as other digital chips -- this might degrade performance, but I'm maybe ok with that.

I'm kinda floundering my way through this with only partial understanding, and it's very likely that all this analog mumbo-jumbo will go wrong and not work the first time -- but fortunately the `PPU2.TST` digital output will likely work, so it's not fatal. Probably.
